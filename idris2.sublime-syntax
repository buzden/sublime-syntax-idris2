%YAML 1.2
---
# http://www.sublimetext.com/docs/syntax.html
name: Idris
file_extensions:
  - idr
scope: source.idris2
contexts:
  main:
    - match: \b(if|then|else|case|of|impossible)\b
      scope: keyword.control.conditional.idris2
    - match: \b(let|rewrite|in|do)\b
      scope: keyword.control.flow.idris2
    - match: \b(prefix|infix|infixl|infixr|autobind|typebind)\b
      scope: keyword.declaration.fixity.idris2
    - match: \b(forall)\b
      scope: keyword.other.forall.idris2
    - match: \b(constructor)\b
      scope: keyword.declaration.struct.idris2
    - match: \b(namespace)\b
      scope: keyword.control.import.namespace.idris2
    - match: \b(failing)\b
      scope: keyword.other.failing.idris2
    - match: \b(where|with|syntax|proof|using)\b
      scope: keyword.other.idris2
    - match: (%[^ ]+)
      scope: keyword.other.pragma.idris2
      comment: Pragmas like `%language`, `%inline`, and expressions like `%search`
    - match: (\?[^ ]+)
      scope: variable.function.typed-hole.idris2
      comment: Typed holes
    - match: (~)
      scope: keyword.operator.quasiquote.idris2
      comment: Anti-quote
    - match: \b(total|covering|partial)\b
      scope: storage.modifier.totality.idris2
    - match: \b(public|private|export|implicit)\b
      scope: storage.modifier.visibility.idris2
    - match: |-
        (--).*$
        ?
      comment: Line comment
      scope: comment.line.idris2
    - match: |-
        (\|\|\|).*$
        ?
      comment: Line comment
      scope: comment.documentation.line.idris2
    - include: multiline_comment
    - match: \b(module)\b
      captures:
        1: keyword.control.idris2
      push:
        - meta_scope: meta.module.idris2
        - match: ($|;|(?=--))
          pop: true
        - match: '([a-zA-Z0-9._'']+)'
          scope: meta.declaration.module.idris2
    - match: \b(import\s+public|import)\b
      captures:
        1: keyword.control.import.idris2
      push:
        - meta_scope: meta.import.idris2
        - match: ($|;|(?=--))
          pop: true
        - match: '([a-zA-Z0-9._'']+)'
          scope: support.other.module.idris2
    - include: param_decl
    - include: data_decl
    - include: function_signature
    - include: ty_expression
  context_signature:
    - match: '(\()((?=.*\)\s*=>)|(?=[^)]*$))'
      comment: |
        For things like '(Eq a, Show a) =>'
        It begins with '(' either followed by ') =>' on the same line,
        or anything but ')' until the end of line.
      captures:
        1: punctuation.context.begin.idris2
      push:
        - meta_scope: meta.context-signature.idris2
        - match: (\))\s*(=>)
          captures:
            1: punctuation.context.end.idris2
            2: keyword.operator.double-arrow.idris2
          pop: true
        - include: ty_expression
  data_ctor:
    - match: '(?:\(\))|(?:\b[\p{Lu}\p{Lt}][\p{Ll}_\p{Lu}\p{Lt}\p{Nd}'']*(?:\.[\p{Lu}\p{Lt}][\p{Ll}_\p{Lu}\p{Lt}\p{Nd}'']*)*\b)'
      scope: entity.name.function.ctor.idris2
  data_decl:
    - match: \b(data|record|interface|implementation)\s
      captures:
        1: keyword.declaration.type.idris2
      push:
        - meta_scope: meta.declaration.data.idris2
        - match: \b(where)\b|(=)|$
          captures:
            1: keyword.other.idris2
            2: keyword.operator.idris2
          pop: true
        - include: ty_expression
  delimiter:
    - match: '[\(\)\[\]{},;]'
      scope: punctuation.delimiter.idris2
  escape_characters:
    - match: '\\(NUL|SOH|STX|ETX|EOT|ENQ|ACK|BEL|BS|HT|LF|VT|FF|CR|SO|SI|DLE|DC1|DC2|DC3|DC4|NAK|SYN|ETB|CAN|EM|SUB|ESC|FS|GS|RS|US|SP|DEL|[abfnrtv\\\"''\&])'
      scope: constant.character.escape.ascii.idris2
    - match: '\\o[0-7]+|\\x[0-9A-Fa-f]+|\\[0-9]+'
      scope: constant.character.escape.octal.idris2
    - match: '\^[A-Z@\[\]\\\^_]'
      scope: constant.character.escape.control.idris2
  function_signature:
    - match: '(?:([\w'']+)|\((\.[\w'']+)\)|\(([:!#\$%&*+./<=>?@\\\^|-~]+)\))\s*(?:,\s*(?:([\w'']+)|\((\.[\w'']+)\)|\(([:!#\$%&*+./<=>?@\\\^|-~]+)\))\s*)?(?:,\s*(?:([\w'']+)|\((\.[\w'']+)\)|\(([:!#\$%&*+./<=>?@\\\^|-~]+)\))\s*)?(:)(?!:)'
      comment: |
        The end patterm is a bit tricky. It's either ';' or something, at the end of the line,
        but not '->', because a type signature can be multiline. Though, it doesn't help, if you
        break the signature before arrows.
        Unfortunately, when some names are listed, we support when there are only two or three of them, and we have repretition on the pattern above.
        Repetition using `*` breaks captures (except the last one).
      captures:
        1: entity.name.function.idris2
        2: entity.name.function.idris2
        3: entity.name.function.idris2
        4: entity.name.function.idris2
        5: entity.name.function.idris2
        6: entity.name.function.idris2
        7: entity.name.function.idris2
        8: entity.name.function.idris2
        9: entity.name.function.idris2
        10: keyword.operator.colon.idris2
      push:
        - meta_scope: meta.function.type-signature.idris2
        - match: (?!->)
          pop: true
        - include: context_signature
        - include: ty_expression
  infix_function:
    - match: '`'
      captures:
        0: punctuation.definition.entity.idris2
      push:
        - meta_scope: keyword.operator.word.idris2
        - match: '`'
          captures:
            0: punctuation.definition.entity.idris2
          pop: true
  language_const:
    - match: \b_\b
      scope: constant.language.underscore.idris2
  multiline_comment:
    - match: '\{-'
      comment: Block comment
      push:
        - meta_scope: comment.block.idris2
        - match: '-\}'
          pop: true
        - include: multiline_comment
  number_float:
    - match: '\b([0-9]+\.[0-9]+([eE][+-]?[0-9]+)?|[0-9]+[eE][+-]?[0-9]+)\b'
      comment: float literal
      scope: constant.numeric.float.idris2
  number_integer:
    - match: '\b([0-9]+|0([xX][0-9a-fA-F]+|[oO][0-7]+))\b'
      comment: integer literal
      scope: constant.numeric.idris2
  operator:
    - match: '\?[-!#\$%&\*\+\.\/<=>@\\^|~:]+|[-!#\$%&\*\+\.\/<=>@\\^|~:\?][-!#\$%&\*\+\.\/<=>@\\^|~:]*'
      scope: keyword.operator.idris2
  param_decl:
    - match: \b(parameters)\s+(\()
      captures:
        1: keyword.other.idris2
        2: punctuation.context.begin.idris2
      push:
        - meta_scope: meta.declaration.data.idris2
        - match: (\))$
          captures:
            1: punctuation.context.end.idris2
          pop: true
        - include: ty_expression
  parameter_type:
    - match: '(\()([\w'']+)\s*(:)(?!:)'
      comment: '(x : Nat)'
      captures:
        1: punctuation.delimiter.idris2
        2: variable.parameter.idris2
        3: keyword.operator.annot.idris2
      push:
        - meta_scope: meta.parameter.named.idris2
        - match: \)
          captures:
            0: punctuation.delimiter.idris2
          pop: true
        - include: ty_expression
    - match: '(\{)((auto|default .+)\s+)?([\w'']+)\s*(:)(?!:)'
      comment: '{auto p : a = b}'
      captures:
        1: punctuation.delimiter.idris2
        2: storage.modifier.implicits.idris2
        4: variable.parameter.idris2
        5: keyword.operator.annot.idris2
      push:
        - meta_scope: meta.parameter.implicit.idris2
        - match: '\}'
          captures:
            0: punctuation.delimiter.idris2
          pop: true
        - include: ty_expression
  quasiquote_bracket:
    - match: '`{'
      captures:
        0: keyword.operator.quasiquote.idris2
      push:
        - meta_scope: meta.quasiquote.idris2
        - match: '}'
          captures:
            0: keyword.operator.quasiquote.idris2
          pop: true
        - include: data_ctor
  quasiquote_paren:
    - match: '`\('
      captures:
        0: keyword.operator.quasiquote.idris2
      push:
        - meta_scope: meta.quasiquote.idris2
        - match: '\)'
          captures:
            0: keyword.operator.quasiquote.idris2
          pop: true
        - include: main
  quasiquote_square_bracket:
    - match: '`\['
      captures:
        0: keyword.operator.quasiquote.idris2
      push:
        - meta_scope: meta.quasiquote.idris2
        - match: '\]'
          captures:
            0: keyword.operator.quasiquote.idris2
          pop: true
        - include: main
  string_interpolation:
    - match: '\\{'
      captures:
        0: string.quoted.double.idris2
      push:
        - clear_scopes: true
        - meta_content_scope: source.idris2
        - match: '}'
          captures:
            0: string.quoted.double.idris2
          pop: true
        - include: main
  string:
    - match: '"'
      captures:
        0: punctuation.definition.string.begin.idris2
      push:
        - meta_scope: string.quoted.double.idris2
        - match: '"'
          captures:
            0: punctuation.definition.string.end.idris2
          pop: true
        - include: string_interpolation
        - include: escape_characters
  char:
    - match: "'"
      captures:
        0: punctuation.definition.string.begin.idris2
      push:
        - meta_scope: string.quoted.single.idris2
        - match: "'"
          captures:
            0: punctuation.definition.string.end.idris2
          pop: true
        - include: escape_characters
      comment: TODO to match only a single char
  ty_expression:
    - match: '->'
      scope: keyword.operator.arrow.idris2
    - include: parameter_type
    - include: language_const
    - include: operator
    - include: quasiquote_paren
    - include: quasiquote_bracket
    - include: quasiquote_square_bracket
    - include: infix_function
    - include: data_ctor
    - include: delimiter
    - include: number_integer
    - include: number_float
    - include: string
    - include: char
